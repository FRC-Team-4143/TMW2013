// RobotBuilder Version: 0.0.2
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in th future.
#include "DriveTrain.h"
#include "../Robotmap.h"
#include "../Commands/CrabCom.h"
#include "../Commands/SteerCom.h"
DriveTrain::DriveTrain() : Subsystem("DriveTrain") {
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	frontRightPos = RobotMap::driveTrainFrontRightPos;
	frontRightSteer = RobotMap::driveTrainFrontRightSteer;
	frontRight = RobotMap::driveTrainFrontRight;
	frontLeftPos = RobotMap::driveTrainFrontLeftPos;
	frontLeftSteer = RobotMap::driveTrainFrontLeftSteer;
	frontLeft = RobotMap::driveTrainFrontLeft;
	rearRightPos = RobotMap::driveTrainRearRightPos;
	rearRightSteer = RobotMap::driveTrainRearRightSteer;
	rearRight = RobotMap::driveTrainRearRight;
	rearLeftPos = RobotMap::driveTrainRearLeftPos;
	rearLeftSteer = RobotMap::driveTrainRearLeftSteer;
	rearLeft = RobotMap::driveTrainRearLeft;
	frontRightDrive = RobotMap::driveTrainFrontRightDrive;
	frontLeftDrive = RobotMap::driveTrainFrontLeftDrive;
	rearRightDrive = RobotMap::driveTrainRearRightDrive;
	rearLeftDrive = RobotMap::driveTrainRearLeftDrive;
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
}
    
void DriveTrain::InitDefaultCommand() {
	// Set the default command for a subsystem here.
	//SetDefaultCommand(new MySpecialCommand());
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
	SetDefaultCommand(new SteerCom());
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
}
// Put methods for controlling this subsystem
// here. Call these from Commands.
void DriveTrain::Crab(float radian) {
	
		position = 768 - 512/pi*radian; //converts radians to counts for encoders
				
		//Set Steering PID Setpoints
		Robot::driveTrain->frontLeft->SetSetpoint(position);
		Robot::driveTrain->frontRight->SetSetpoint(position);
		Robot::driveTrain->rearLeft->SetSetpoint(position);
		Robot::driveTrain->rearRight->SetSetpoint(position);
		
		//Set drive speeds
		Robot::driveTrain->frontLeftDrive->Set(-Robot::oi->getDriverJoystick()->GetY());
		Robot::driveTrain->frontRightDrive->Set(Robot::oi->getDriverJoystick()->GetY());
		Robot::driveTrain->rearLeftDrive->Set(-Robot::oi->getDriverJoystick()->GetY());
		Robot::driveTrain->rearRightDrive->Set(Robot::oi->getDriverJoystick()->GetY());
}
void DriveTrain::Steer(float radian, float speed) {
		
	thetaRC = pi - radian;  //convert steering angle to rear center wheel angle
	
	if(thetaRC != pi / 2)	//If we are not driving straight forward...
	{
		if(thetaRC < pi / 2)	//Right Turn
		{
			this->RightTurn4Wheels();
		}
		else if(thetaRC > pi / 2)	//Left Turn
		{
			this->LeftTurn4Wheels();
		}
	}
	else	//thetaRC = pi / 2
	{
		thetaFL = pi / 2;
		thetaFR = pi / 2;
		thetaRL = pi / 2;
		thetaRR = pi / 2;
		FLRatio = 1;
		FRRatio = 1;
		RLRatio = 1;
		RRRatio = 1;
	}
	//Solve for fastest wheel speed
	double speedarray[] = {fabs(FL), fabs(FR), fabs(RL), fabs(RR)};
		
	 int length = 4;
     double maxspeed = speedarray[0];
     for(int i = 1; i < length; i++)
     {
          if(speedarray[i] > maxspeed)
                maxspeed = speedarray[i];
     }
		 
	//Set ratios based on maximum wheel speed
	FLRatio = FL/maxspeed;
	FRRatio = FR/maxspeed;
	RLRatio = RL/maxspeed;
	RRRatio = RR/maxspeed;
	
	//Set drive speeds
	Robot::driveTrain->frontLeftDrive->Set(-FLRatio*Robot::oi->getDriverJoystick()->GetY());
	Robot::driveTrain->frontRightDrive->Set(FRRatio*Robot::oi->getDriverJoystick()->GetY());
	Robot::driveTrain->rearLeftDrive->Set(-RLRatio*Robot::oi->getDriverJoystick()->GetY());
	Robot::driveTrain->rearRightDrive->Set(RRRatio*Robot::oi->getDriverJoystick()->GetY());
	
	//Set Steering PID Setpoints
	Robot::driveTrain->frontLeft->SetSetpoint(768 - 512/pi*thetaFL);
	Robot::driveTrain->frontRight->SetSetpoint(768 - 512/pi*thetaFR);
	Robot::driveTrain->rearLeft->SetSetpoint(768 - 512/pi*thetaRL);
	Robot::driveTrain->rearRight->SetSetpoint(768 - 512/pi*thetaRR);
}

void DriveTrain::LeftTurn4Wheels()
{
	Z = ((A * X) * tan(pi - thetaRC));				//pi was subtracted out of this earlier
	
	thetaRL = pi - atan((Z - W) / (A * X));
	thetaRR = pi - atan((Z + W) / (A * X));
	thetaFR = pi / 2;
	thetaFL = pi / 2;
	
	if(A != 1)
	{
		thetaFL = atan((Z - Y) / ((1 - A) * X));	//These are identical for right and left turns
		thetaFR = atan((Z + Y) / ((1 - A) * X));	//These are identical for right and left turns
	}
	//Solve for radii (wheel speed)
	FL = (Z - Y) / sin(thetaFL);
	FR = (Z + Y) / sin(thetaFR);
	RL = (Z - W) / sin(pi - thetaRL);
	RR = (Z + W) / sin(pi - thetaRR);
}
void DriveTrain::RightTurn4Wheels()
{	
	Z = ((A * X) * tan(thetaRC));				//pi was subtracted out of this earlier
	
	thetaRL = atan((Z + W) / (A * X));
	thetaRR = atan((Z - W) / (A * X));
	thetaFR = pi / 2;
	thetaFL = pi / 2;
	
	if(A != 1)
	{
		thetaFR = pi - atan((Z - Y) / ((1 - A) * X));	//These are identical for right and left turns
		thetaFL = pi - atan((Z + Y) / ((1 - A) * X));	//These are identical for right and left turns
	}
	
	FL = (Z + Y) / sin(pi - thetaFL);
	FR = (Z - Y) / sin(pi - thetaFR);
	RL = (Z + W) / sin(thetaRL);
	RR = (Z - W) / sin(thetaRR);
}
