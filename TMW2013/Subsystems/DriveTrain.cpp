// RobotBuilder Version: 0.0.2
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in th future.
#include "DriveTrain.h"
#include "../Robotmap.h"
#include "../Commands/CrabDrive.h"
#include "../Commands/SteerDrive.h"
DriveTrain::DriveTrain(): 
Subsystem("DriveTrain")
{
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	frontRightPos = RobotMap::driveTrainFrontRightPos;
	frontRightSteer = RobotMap::driveTrainFrontRightSteer;
	frontRight = RobotMap::driveTrainFrontRight;
	frontLeftPos = RobotMap::driveTrainFrontLeftPos;
	frontLeftSteer = RobotMap::driveTrainFrontLeftSteer;
	frontLeft = RobotMap::driveTrainFrontLeft;
	rearRightPos = RobotMap::driveTrainRearRightPos;
	rearRightSteer = RobotMap::driveTrainRearRightSteer;
	rearRight = RobotMap::driveTrainRearRight;
	rearLeftPos = RobotMap::driveTrainRearLeftPos;
	rearLeftSteer = RobotMap::driveTrainRearLeftSteer;
	rearLeft = RobotMap::driveTrainRearLeft;
	frontLeftDrive = RobotMap::driveTrainFrontLeftDrive;
	frontRightDrive = RobotMap::driveTrainFrontRightDrive;
	rearLeftDrive = RobotMap::driveTrainRearLeftDrive;
	rearRightDrive = RobotMap::driveTrainRearRightDrive;
	gyroscope = RobotMap::driveTrainGyroscope;
	lineSensorL = RobotMap::driveTrainLineSensorL;
	lineSensorR = RobotMap::driveTrainLineSensorR;
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	wheelSpokeCounter = RobotMap::wheelSpokeCounter;
	GyroZeroFlag = false;
	GyroZeroTime = GetClock();
	FLInv = 1;
	FRInv = 1;
	RRInv = 1;
	RLInv = 1;
	DriveBackFlag = false;
}
    
void DriveTrain::InitDefaultCommand() {
	// Set the default command for a subsystem here.
	//SetDefaultCommand(new MySpecialCommand());
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
	SetDefaultCommand(new SteerDrive());
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
	driveFront = true;
}
// Put methods for controlling this subsystem
// here. Call these from Commands.
void DriveTrain::SetWheelbase(float w, float x, float y) {
	W=w;
	X=x;
	Y=y;
}
void DriveTrain::SetMaxSpeed(float MaxSpeed) {
	MaxSpeed = maxspeed;
}
void DriveTrain::SetGyroReference(){
	gyroreference = gyroscope->GetAngle();
}
void DriveTrain::SetOffsets(int FLOff, int FROff, int RLOff, int RROff) {
	FLOffset = FLOff;
	FROffset = FROff;
	RLOffset = RLOff;
	RROffset = RROff;
}
void DriveTrain::ToggleFrontBack(){
	driveFront = !driveFront;
}
void DriveTrain::Crab(float radian, float speed) {
	
		position = 485 + 485/pi*radian; //converts radians to counts for encoders
			
	
		SetSteerSetpoint(position, position, position, position);
		SetDriveSpeed(speed, -speed, speed, -speed);
}
void DriveTrain::Steer(float radian, float speed, float a) {
	
	A=a;
	
	thetaRC = pi - radian;  //convert steering angle to rear center wheel angle
	
	if(thetaRC != pi / 2)	//If we are not driving straight forward...
	{
		if(thetaRC < pi / 2)	//Right Turn
		{
			this->RightTurn4Wheels();
		}
		else if(thetaRC > pi / 2)	//Left Turn
		{
			this->LeftTurn4Wheels();
		}
	}
	else	//thetaRC = pi / 2
	{
		thetaFL = pi / 2;
		thetaFR = pi / 2;
		thetaRL = pi / 2;
		thetaRR = pi / 2;
		FLRatio = 1;
		FRRatio = 1;
		RLRatio = 1;
		RRRatio = 1;
	}
	//Solve for fastest wheel speed
	double speedarray[] = {fabs(FL), fabs(FR), fabs(RL), fabs(RR)};
		
	 int length = 4;
     double maxspeed = speedarray[0];
     for(int i = 1; i < length; i++)
     {
          if(speedarray[i] > maxspeed)
                maxspeed = speedarray[i];
     }
		 
	//Set ratios based on maximum wheel speed
	FLRatio = FL/maxspeed;
	FRRatio = FR/maxspeed;
	RLRatio = RL/maxspeed;
	RRRatio = RR/maxspeed;
	
	//Set drive speeds
	SetDriveSpeed(-FLRatio*speed, FRRatio*speed, -RLRatio*speed, RRRatio*speed);
	
	//Set Steering PID Setpoints
	float FLSetPoint = (242 + 485/pi*thetaFL);
	float FRSetPoint = (242 + 485/pi*thetaFR);
	float RLSetPoint = (242 + 485/pi*thetaRL);
	float RRSetPoint = (242 + 485/pi*thetaRR);
	
	SetSteerSetpoint(FLSetPoint, FRSetPoint, RLSetPoint, RRSetPoint);
	}
void DriveTrain::LeftTurn4Wheels()
{
	Z = ((A * X) * tan(pi - thetaRC));				//pi was subtracted out of this earlier
	
	thetaRL = pi - atan((Z - W) / (A * X));
	thetaRR = pi - atan((Z + W) / (A * X));
	thetaFR = pi / 2;
	thetaFL = pi / 2;
	
	if(A != 1)
	{
		thetaFL = atan((Z - Y) / ((1 - A) * X));	//These are identical for right and left turns
		thetaFR = atan((Z + Y) / ((1 - A) * X));	//These are identical for right and left turns
	}
	//Solve for radii (wheel speed)
	FL = (Z - Y) / sin(thetaFL);
	FR = (Z + Y) / sin(thetaFR);
	RL = (Z - W) / sin(pi - thetaRL);
	RR = (Z + W) / sin(pi - thetaRR);
}
void DriveTrain::RightTurn4Wheels()
{	
	Z = ((A * X) * tan(thetaRC));				//pi was subtracted out of this earlier
	
	thetaRL = atan((Z + W) / (A * X));
	thetaRR = atan((Z - W) / (A * X));
	thetaFR = pi / 2;
	thetaFL = pi / 2;
	
	if(A != 1)
	{
		thetaFR = pi - atan((Z - Y) / ((1 - A) * X));	//These are identical for right and left turns
		thetaFL = pi - atan((Z + Y) / ((1 - A) * X));	//These are identical for right and left turns
	}
	
	FL = (Z + Y) / sin(pi - thetaFL);
	FR = (Z - Y) / sin(pi - thetaFR);
	RL = (Z + W) / sin(thetaRL);
	RR = (Z - W) / sin(thetaRR);
}
int DriveTrain::CorrectSteerSetpoint(int setpoint) {
	
	
if (setpoint < 0)
{
	return setpoint + 970;
}
else if (setpoint > 970)
{
	return setpoint - 970;
}
else if (setpoint == 970)
{
	return 0;
}
else
{
	return setpoint;
}
}
void DriveTrain::SetSteerSetpoint(float FLSetPoint, float FRSetPoint, float RLSetPoint, float RRSetPoint)
{	
	if(driveFront) {
		
		if(fabs((int)FLSetPoint + FLOffset - frontLeftPos->GetAverageValue()) < 242 || fabs((int)FLSetPoint + FLOffset - frontLeftPos->GetAverageValue()) > 768)
		{
			frontLeft->SetSetpoint(CorrectSteerSetpoint((int)FLSetPoint + FLOffset));
			FLInv = 1;
		}
			else
		{
			frontLeft->SetSetpoint(CorrectSteerSetpoint((int)FLSetPoint + FLOffset-485));
			FLInv = -1;
		}
		
		if(fabs((int)FRSetPoint + FROffset - frontRightPos->GetAverageValue()) < 242 || fabs((int)FRSetPoint + FROffset - frontRightPos->GetAverageValue()) > 768)
		{
			frontRight->SetSetpoint(CorrectSteerSetpoint((int)FRSetPoint + FROffset));
			FRInv = 1;
		}
			else
		{
			frontRight->SetSetpoint(CorrectSteerSetpoint((int)FRSetPoint + FROffset-485));
			FRInv = -1;
		}
		
		if(fabs((int)RLSetPoint + RLOffset - rearLeftPos->GetAverageValue()) < 242 || fabs((int)RLSetPoint + RLOffset - rearLeftPos->GetAverageValue()) > 768)
		{
			rearLeft->SetSetpoint(CorrectSteerSetpoint((int)RLSetPoint + RLOffset));
			RLInv = 1;
		}
			else
		{
			rearLeft->SetSetpoint(CorrectSteerSetpoint((int)RLSetPoint + RLOffset-485));
			RLInv = -1;
		}
		
		if(fabs((int)RRSetPoint + RROffset - rearRightPos->GetAverageValue()) < 242 || fabs((int)RRSetPoint + RROffset - rearRightPos->GetAverageValue()) > 768)
		{
			rearRight->SetSetpoint(CorrectSteerSetpoint((int)RRSetPoint + RROffset));
			RRInv = 1;
		}
			else
		{
			rearRight->SetSetpoint(CorrectSteerSetpoint((int)RRSetPoint + RROffset-485));
			RRInv = -1;
		}
	
	}
	
	else {
	
		if(fabs((int)RRSetPoint + FLOffset - frontLeftPos->GetAverageValue()) < 242 || fabs((int)RRSetPoint + FLOffset - frontLeftPos->GetAverageValue()) > 768)
		{
			frontLeft->SetSetpoint(CorrectSteerSetpoint((int)RRSetPoint + FLOffset));
			FLInv = 1;
		}
			else
		{
			frontLeft->SetSetpoint(CorrectSteerSetpoint((int)RRSetPoint + FLOffset-485));
			FLInv = -1;
		}
		
		if(fabs((int)RLSetPoint + RLOffset - frontRightPos->GetAverageValue()) < 242 || fabs((int)RLSetPoint + FROffset - frontRightPos->GetAverageValue()) > 768)
		{
			frontRight->SetSetpoint(CorrectSteerSetpoint((int)RLSetPoint + FROffset));
			FRInv = 1;
		}
			else
		{
			frontRight->SetSetpoint(CorrectSteerSetpoint((int)RLSetPoint + FROffset-485));
			FRInv = -1;
		}
		
		if(fabs((int)FRSetPoint + RLOffset - rearLeftPos->GetAverageValue()) < 242 || fabs((int)FRSetPoint + RLOffset - rearLeftPos->GetAverageValue()) > 768)
		{
			rearLeft->SetSetpoint(CorrectSteerSetpoint((int)FRSetPoint + RLOffset));
			RLInv = 1;
		}
			else
		{
			rearLeft->SetSetpoint(CorrectSteerSetpoint((int)FRSetPoint + RLOffset-485));
			RLInv = -1;
		}
		
		if(fabs((int)FLSetPoint + RROffset - rearRightPos->GetAverageValue()) < 242 || fabs((int)FLSetPoint + RROffset - rearRightPos->GetAverageValue()) > 768)
		{
			rearRight->SetSetpoint(CorrectSteerSetpoint((int)FLSetPoint + RROffset));
			RRInv = 1;
		}
			else
		{
			rearRight->SetSetpoint(CorrectSteerSetpoint((int)FLSetPoint + RROffset-485));
			RRInv = -1;
		}
	}
		
		
}
void DriveTrain::SetDriveSpeed(float FLSpeed, float FRSpeed, float RLSpeed, float RRSpeed) {
	
	if(driveFront) {
		frontLeftDrive->Set(FLSpeed*FLInv);
		frontRightDrive->Set(FRSpeed*FRInv);
		rearLeftDrive->Set(RLSpeed*RLInv);
		rearRightDrive->Set(RRSpeed*RRInv);
	}
	else {
		frontLeftDrive->Set(RRSpeed*FLInv);
		frontRightDrive->Set(RLSpeed*FRInv);
		rearLeftDrive->Set(FRSpeed*RLInv);
		rearRightDrive->Set(FLSpeed*RRInv);
	}
}
void DriveTrain::Pivot(float ROT, float y, float x, bool UseGyro)
{
	
	robotangle = (gyroscope->GetAngle())*pi/180;
	
	float FWD = y;
	float STR = x;
	if(UseGyro)
	{
		FWD = y*cos(robotangle) + x*sin(robotangle);
		STR = -y*sin(robotangle) + x*cos(robotangle);
	}		
		
	radius = sqrt(pow(2*Y,2)+pow(X,2));
	
	AP = STR - ROT*X/radius;
	BP = STR + ROT*X/radius;
	CP = FWD - ROT*2*Y/radius;
	DP = FWD + ROT*2*Y/radius;
	
	float FLSetPoint = 485;
	float FRSetPoint = 485;
	float RLSetPoint = 485;
	float RRSetPoint = 485;
	
	if(DP != 0 || BP != 0)
		FLSetPoint = (485 + 485/pi*atan2(BP,DP));
	if(BP != 0 || CP != 0)	
		FRSetPoint = (485 + 485/pi*atan2(BP,CP));
	if(AP != 0 || DP != 0)
		RLSetPoint = (485 + 485/pi*atan2(AP,DP));
	if(AP != 0 || CP != 0)
		RRSetPoint = (485 + 485/pi*atan2(AP,CP));
	
	
	SetSteerSetpoint(FLSetPoint, FRSetPoint, RLSetPoint, RRSetPoint);
	FL = sqrt(pow(BP,2)+pow(DP,2));
	FR = sqrt(pow(BP,2)+pow(CP,2));
	RL = sqrt(pow(AP,2)+pow(DP,2));
	RR = sqrt(pow(AP,2)+pow(CP,2));
	
	
	//Solve for fastest wheel speed
	double speedarray[] = {fabs(FL), fabs(FR), fabs(RL), fabs(RR)};
		
	 int length = 4;
     double maxspeed = speedarray[0];
     for(int i = 1; i < length; i++)
     {
          if(speedarray[i] > maxspeed)
                maxspeed = speedarray[i];
     }
		 
	//Set ratios based on maximum wheel speed
	
    if(maxspeed > 1 || maxspeed < -1)
    {
		FLRatio = FL/maxspeed;
		FRRatio = FR/maxspeed;
		RLRatio = RL/maxspeed;
		RRRatio = RR/maxspeed;
    }
    else
    {
		FLRatio = FL;
		FRRatio = FR;
		RLRatio = RL;
		RRRatio = RR;
    }
    
	
	//Set drive speeds
	SetDriveSpeed(FLRatio, -FRRatio, RLRatio, -RRRatio);
	
}
void DriveTrain::Lock()
{
	SetSteerSetpoint(607, 364, 607, 364);
	SetDriveSpeed(0,0,0,0);
}
void DriveTrain::SideLock()
{
	SetSteerSetpoint(364, 607, 122, 849);
	SetDriveSpeed(0,0,0,0);
}
bool DriveTrain::ZeroGyro(float InitTime)
{
	bool Done = false;
	
	if(GyroZeroFlag == false)
	{
		GyroZeroFlag = true;
		GyroZeroTime = GetClock();
	}
	else
	{
		if(GetClock() > GyroZeroTime + InitTime)
		{
			gyroscope->InitGyro();
			GyroZeroFlag = false;
			Done = true;
		}
	}
	
	return GetClock() > GyroZeroTime + InitTime + 6;
}
bool DriveTrain::GetDriveBackFlag() {
	return DriveBackFlag;
}
void DriveTrain::SetDriveBackFlag(bool flag) {
	DriveBackFlag = flag;
}
